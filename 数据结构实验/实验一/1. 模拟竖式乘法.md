1. 初始化三个指针：

- `p1`：指向 `nums1` 的最后一个有效元素（`m-1`）。
- `p2`：指向 `nums2` 的最后一个有效元素（`n-1`）。
- `p`：指向 `nums1` 的最后一个位置（`m+n-1`）。

2. 从后向前遍历：

- 比较 `nums1[p1]` 和 `nums2[p2]`，将较大的元素放入nums1[p]`，并移动相应的指针。
- 重复直到 `p1` 或 `p2` 小于 0。

3. 处理剩余元素：

- 如果 `nums2` 中还有剩余元素（`p2>=0`），将其复制到`nums1`中。



### **1. 模拟竖式乘法**

- **目标**：计算 R*(*n*)×*n*。
- **过程**：
  1. 从链表的**尾结点**（最低位）开始，逐位乘以 *n*。
  2. 每个结点只能存储一个数字（0-9），所以如果乘法的结果大于等于 10，需要将**进位**保存下来。
  3. 每次计算乘法时，还需要加上**前一个结点的进位**。
  4. 重复上述过程，直到处理完链表的**头节点**（最高位）。
- **举例**：
  假设链表存储的数字是 `123`，*n*=2：
  - 从最低位 `3` 开始：3×2=63×2=6，没有进位。
  - 中间位 `2`：2×2=42×2=4，没有进位。
  - 最高位 `1`：1×2=21×2=2，没有进位。
  - 最终结果是 `246`。

------

### **2. 模拟竖式除法**

- **目标**：计算 R(n)×n/(2n+1)。

- **过程**：

  1. 从链表的**头节点**（最高位）开始，逐位除以 (2n+1)。

  2. 每一位的计算公式是：

     当前结点的值=当前结点的值+上一个结点的余数×10(2n+1)当前结点的值=(2*n*+1)当前结点的值+上一个结点的余数×10

  3. 保存当前结点除以 (2n+1)后的**余数**，用于下一位的计算。

  4. 重复上述过程，直到处理完链表的**尾结点**（最低位）。

- **举例**：
  假设链表存储的数字是 `246`，2n+1=5：

  - 从最高位 `2` 开始：(2+0×10)/5=0(2+0×10)/5=0，余数是 `2`。
  - 中间位 `4`：(4+2×10)/5=4(4+2×10)/5=4，余数是 `4`。
  - 最低位 `6`：(6+4×10)/5=9(6+4×10)/5=9，余数是 `1`。
  - 最终结果是 `049`（即 `49`），余数是 `1`。